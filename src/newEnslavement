#include "Enslavement.h"


Enslavement::Enslavement(unsigned long deltaT, double acceleration, double velocityMax,
    Motor *leftMotor, Motor *rightMotor)
{
    this->odometry = Odometry::getInst(NULL, NULL);
    this->leftMotor = leftMotor;
    this->rightMotor = rightMotor;
    this->distancePID = new Pid(0.9, 0, 0.1, deltaT);
    this->orientationPID = new Pid(2.3, 0, 0.25, deltaT);

    this->deltaT = deltaT;
    this->lastMillis = 0;


    this->distanceVelocityMax = Odometry::metersToTicks(velocityMax / 1000 * deltaT); //m.s^-1 => ticks.deltaT^-1
    this->distanceAcceleration = Odometry::metersToTicks(acceleration / 1000 / 1000 * deltaT * deltaT); //m.s^-2 => ticks.deltaT^-2
    this->orientationVelocityMax = this->distanceVelocityMax / Odometry::ENTRAXE / 2.0;
    this->orientationAcceleration = this->distanceAcceleration / Odometry::ENTRAXE / 2.0;

    this->theoricalDistance = 0;
    this->theoricalDistanceVelocity = 0;

    this->theoricalOrientation = 0;
    this->theoricalOrientationVelocity = 0;

    this->xObjective = 0;
    this->yObjective = 0;
    this->running = false;
    this->mode = POLAR;
}


Enslavement::~Enslavement() { }


void Enslavement::goTo(double x, double y, bool forceFace)
{
    if (!this->running)
        this->running = true;

    this->xObjective = x;
    this->yObjective = y;
}


void Enslavement::turn(double theta)
{
    this->running = true;
    this->orientationObjective = theta * 0.0174532925;

    CarthesianCoordinates coordinates = this->odometry->getCoordinates();
    this->xObjective = coordinates.x;
    this->yObjective = coordinates.y;
}


void Enslavement::compute()
{
    unsigned long now = millis();
    unsigned int timeElapsed = (now - this->lastMillis);

    if (timeElapsed >= this->deltaT)
    {
        this->lastMillis = now;

        this->odometry->update();
        CarthesianCoordinates coordinates = this->odometry->getCoordinates();
        double orientation = this->odometry->getOrientation();

        this->odometry->getLeftEncoder()->resetTicks();
        this->odometry->getRightEncoder()->resetTicks();

        if (!this->running) {
            return;
        }


        CarthesianCoordinates moveCoordinates = {this->xObjective - coordinates.x, this->yObjective - coordinates.y};
        double moveAngle = atan2(moveCoordinates.y, moveCoordinates.x) - orientation;

        double remainingDistance = 0;
        int direction = 1;
        if (fabs(moveAngle) > M_PI)
        {
            direction = -1;
        }
        remainingDistance = direction * sqrt(pow(moveCoordinates.x, 2) + pow(moveCoordinates.y, 2));

        double remainingOrientation = this->orientationObjective - orientation;
        if (fabs(remainingOrientation) > M_PI)
        {
            int sign = (remainingDistance > 0) - (remainingDistance < 0);
            remainingDistance -= sign * 2 * M_PI;
            direction = -1;
        }


        /*
            Error correction
        */

        double distanceCommand = this->distancePID->compute(remainingDistance);
        double orientationCommand = this->orientationPID->compute(remainingOrientation);

        if (this->mode == DEBUG_ORIENTATION)
        {
            distanceCommand = 0;
        }
        else if (this->mode == DEBUG_DISTANCE)
        {
            orientationCommand = 0;
        }

        double leftCommand = distanceCommand+orientationCommand;
        double rightCommand = distanceCommand-orientationCommand;

        // Serial.print("moveDistance: ");
        // Serial.println(moveDistance);
        // Serial.print("moveOrientation: ");
        // Serial.println(moveAngle);
        // Serial.println();
        // Serial.print("orientationCoomand: ");
        // Serial.println(orientationCommand);
        this->leftMotor->run(leftCommand);
        this->rightMotor->run(rightCommand);
    }
}


void Enslavement::stop()
{
    this->leftMotor->stop();
    this->rightMotor->stop();

    this->theoricalOrientation = 0;
    this->orientationVelocityObjective = 0;
    this->theoricalOrientationVelocity = 0;

    this->theoricalDistance = 0;
    this->distanceVelocityObjective = 0;
    this->theoricalDistanceVelocity = 0;

    CarthesianCoordinates coordinates = this->odometry->getCoordinates();
    double orientation = this->odometry->getOrientation();

    this->orientationObjective = orientation;
    this->xObjective = coordinates.x;
    this->yObjective = coordinates.y;
    this->running = false;
}


Pid* Enslavement::getOrientationPID()
{
    return this->orientationPID;
}


Pid* Enslavement::getDistancePID()
{
    return this->distancePID;
}


void Enslavement::setDeltaT(unsigned long deltaT)
{
    this->deltaT = deltaT;
}


void Enslavement::setMode(EnslavementMode newMode)
{
    this->mode = newMode;
}